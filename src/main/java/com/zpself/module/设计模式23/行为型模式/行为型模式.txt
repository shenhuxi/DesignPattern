-----------------------------1.责任链模式-----------------------------
描述：为请求创建了一个接收者对象的链，通常每个接收者都包含对另一个接收者的引用。
      如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。
意图：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。
优点：
    1、降低耦合度。它将请求的发送者和接收者解耦。
    2、简化了对象。使得对象不需要知道链的结构。
    3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。
    4、增加新的请求处理类很方便。
缺点：
    1、不能保证请求一定被接收。
    2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。
    3、可能不容易观察运行时的特征，有碍于除错。
使用场景： 在 JAVA WEB 中遇到很多应用。
    1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。
    2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。
    3、可动态指定一组对象处理请求。



-----------------------------2.命令模式-----------------------------
意图：将一个请求封装成一个对象，从而使您可以用  不同的请求  对客户  进行参数化。
【分析：案例==服务员把菜单准备好、一个人看菜单点菜  、厨师根据菜单炒菜
    0.命令【菜单】 接口通常仅声明一个执行命令的方法。
    0.具体命令会实现各种类型的请求【根据菜名炒菜】。 具体命令自身并不完成工作， 而是会将调用委派给一个业务逻辑对象，但为了简化代码， 这些类可以进行合并。
1.发送者【菜单订单，命令组合】：—类负责对请求进行初始化， 其中必须包含一个成员变量来存储对于命令对象的引用。
  发送者触发命令， 而不向接收者直接发送请求。 注意， 发送者并不负责创建命令对象： 它通常会通过构造函数从客户端处获得预先生成的命令。
2.接收者类包含部分业务逻辑。 几乎任何对象都可以作为接收者。 绝大部分命令只处理如何将请求传递到接收者的细节， 接收者自己会完成实际的工作。
】

优点： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。
缺点：使用命令模式可能会导致某些系统有过多的具体命令类。


*不重要-----------------------------3.解释器模式-----------------------------【太特么凌乱了】
解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式
优点： 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。
缺点： 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。
使用场景：
    1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。
    2、一些重复出现的问题可以用一种简单的语言来进行表达。
    3、一个简单语法需要解释的场景。
注意事项：可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。


-----------------------------4.中介者模式-----------------------------【双方都只用对接中介】
用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护
应用实例：
    1、机场调度系统。
    2、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。
优点： 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。
缺点：中介者会庞大，变得复杂难以维护。
使用场景：
    1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。
    2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。


-----------------------------5.备忘录模式-----------------------------【保存状态、浪费内存+原型模式】
保存一个对象的某个状态，以便在适当的时候恢复对象
优点：  1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。
        2、实现了信息的封装，使得用户不需要关心状态的保存细节。
缺点：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。
使用场景： 1、需要保存/恢复数据的相关状态场景。 2、提供一个可回滚的操作。
注意事项： 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式。



-----------------------------6.观察者模式-----------------------------
当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。
【Subject、Observer：
    1.Subject里面保留一个集合Observer,Observer需要注册到Subject；
    2.当Subject修改了会循环通知这些观察者，调用观察者的update方法
    3.Observer在自己的update里实现自己的逻辑。
】



-----------------------------7.状态模式-----------------------------【通过很多的状态类来改变一个对象的属性，不是很好】
意图：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。
主要解决：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。
何时使用：代码中包含大量与对象状态有关的条件语句。
如何解决：将各种具体的状态类抽象出来。
优点：
    1、封装了转换规则。
    2、枚举可能的状态，在枚举状态之前需要确定状态种类。
    3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。
    4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。
    5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。

缺点：
    1、状态模式的使用必然会增加【系统类和对象的个数。】
    2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序【结构和代码的混乱。】
    3、状态模式对"开闭原则"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。

使用场景： 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。
注意事项：在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。




***-----------------------------8.空对象模式-----------------------------【检查空值,属性boolean isNil()】
在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，
该空对象类将无缝地使用在需要检查空值的地方。



-----------------------------9.策略模式-----------------------------【一个计算工具对象，切换加减乘除的策略，执行的时候采用不同的运算方式】
一个类的行为或其算法可以在运行时更改
何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。
如何解决：将这些算法封装成一个一个的类，任意地替换。
关键代码：实现同一个接口。
优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。
缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。
注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。



-----------------------------10.模板模式-----------------------------【抽取子类公共方法，打上final,其他步骤在子类实现】
主要解决：一些方法通用，却在每一个子类都重新写了这一方法。
何时使用：有一些通用的方法。
如何解决：将这些通用算法抽象出来。
关键代码：【在抽象类实现，其他步骤在子类实现】。
优点： 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。
缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。
使用场景： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。
注意事项：为防止恶意操作，一般模板方法都加上 final 关键词。



-----------------------------11.访问者模式-----------------------------
【
    1.目标类一个方法接受访问者，
    2.将自身引用传入访问者，
    3.访问者根据被访问对象的不同执行不同的重构方法
】
何时使用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要【避免让这些操作"污染"这些对象的类】，使用访问者模式将这些封装到类中。
如何解决：在被访问的类里面加一个对外提供接待访问者的接口。
关键代码：【在数据基础类里面有一个方法接受访问者，将自身引用传入访问者】。
优点：
    1、符合单一职责原则。
    2、优秀的扩展性。
    3、灵活性。
缺点：
    1、具体元素对访问者公布细节，违反了迪米特原则。
    2、具体元素变更比较困难。
    3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。
注意事项：访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。