-----------------------------1.(简单)工厂模式-----------------------------https://www.runoob.com/design-pattern/factory-pattern.html
    创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。
    需要注意的地方就是复杂对象适合使用工厂模式，
而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。
    案例：创建图形，包括实现圆形、长方形、正方形


-----------------------------2.抽象工厂模式-----------------------------https://www.runoob.com/design-pattern/abstract-factory-pattern.html
    抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。----------该超级工厂又称为::其他工厂的工厂。
这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
    在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。


-----------------------------3.单例模式-----------------------------https://www.runoob.com/design-pattern/singleton-pattern.html
    这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。
这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。
1、单例类只能有一个实例。
2、单例类必须自己创建自己的唯一实例。
3、单例类必须给所有其他对象提供这一实例。


-----------------------------4.建造者模式-----------------------------https://www.runoob.com/design-pattern/builder-pattern.html
使用多个简单的对象一步一步构建成一个复杂的对象，它提供了一种创建对象的最佳方式。  ----【创建套餐】
优点： 1、建造者独立，易扩展。 2、便于控制细节风险。
缺点： 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。
与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。
应用实例： 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。 2、JAVA 中的 StringBuilder。


-----------------------------5.原型模式【克隆】【缓存、map】-----------------------------https://www.runoob.com/design-pattern/prototype-pattern.html
用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
 1、当一个系统应该独立于它的产品创建，构成和表示时。
 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。
 3、为了避免创建一个与产品类层次平行的工厂类层次时。
 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。
关键代码： 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，
优点： 1、性能提高。 2、逃避构造函数的约束。
缺点：必须实现 Cloneable 接口。
使用场景：
    1、资源优化场景。
    2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。
    3、性能和安全要求的场景。
    4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。
    5、一个对象多个修改者的场景。
    6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。
    7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。

扩展：克隆
浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。
深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。
    
        /* 浅复制 */  
    public Object clone() throws CloneNotSupportedException {  
        Prototype proto = (Prototype) super.clone();  
        return proto;  
    }  

    /* 深复制 */  
    public Object deepClone() throws IOException, ClassNotFoundException {  
  
        /* 写入当前对象的二进制流 */  
        ByteArrayOutputStream bos = new ByteArrayOutputStream();  
        ObjectOutputStream oos = new ObjectOutputStream(bos);  
        oos.writeObject(this);  
  
        /* 读出二进制流产生的新对象 */  
        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());  
        ObjectInputStream ois = new ObjectInputStream(bis);  
        return ois.readObject();  
    }  
  